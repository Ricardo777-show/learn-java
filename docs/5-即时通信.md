# Java 第五轮考核

## 知识点

-   掌握 Http 协议和 Web 工作原理, 了解 TCP、UDP
-   掌握 WebSocket 原理与实践
-   掌握关系型或非关系型数据库的基本操作
-   掌握消息队列的使用场景，使用方式（RabbitMQ、RocketMQ、Kafka 等）
-   了解并发编程，理解 java 内存模型，进程、线程、协程等并发基本概念

## 背景

众所周知，FanOne 是个家喻户晓的**Aquaman**，她经常在社交软件上找小哥哥们聊天，以至于被多个平台封杀，请你写一个 IM 即时通信系统，让 FanOne 能聊天自由吧！

## 任务

在第四轮的视频网站上添加聊天室功能，和视频审核功能，并优化第四轮的 Sql 语句

> 编写一个 IM 即时通信系统 支持单聊，群聊，并且支持查找一定时间内的聊天记录
>
> 除了优化重构第四轮的模块，你还需要编写以下模块
>
> websocket 模块，联系人模块，会话模块，信息模块

-   重构好友列表逻辑，即为联系人模块

-   对于聊天内容，请使用 Redis + Mysql 的方式实现

-   对于消息的存储，请使用消息队列异步提交

-   会话列表，支持文字，图片交流，屏蔽功能
-   请使用 SpringSecurity 的身份功能，完成视频的审核模块

-   除此之外，~~本轮禁止使用 mybatisPlus~~，对于复杂的 sql 请在 mybatis 的 xml 中书写原生 sql 并进行调优

### Bonus

1. 请考虑你的聊天系统的性能（例如使用 Benchmark 测试）
2. 使用 netty 自己实现一个 websocket
3. 考虑聊天传输的安全性（可以学习一下 Telegram 是如何保证传输安全性的，但是现阶段是做不到的，可以尝试做一些小的安全性优化）
4. 敏感词功能
5. ip 获取+归属地
6. 未读消息数
7. 对于一个聊天系统，性能与并发是你需要考虑的重点，请尝试在代码或文档中说明你是如何考虑并发与性能的

## 参考

-   `spring-boot-starter-websocket`
-   使用 SpringBoot 作为基础框架暴露 http 路由
-   [WebSocket 的 6 种集成方式](https://juejin.cn/post/7111132777394733064)
-   [SpringBoot 如何集成 RabbitMQ](https://juejin.cn/post/7155754742113632293)
-   [即时通讯网 - 即时通讯开发者社区!](http://www.52im.net/)
-   并发与虚拟线程
    -   [OpenJDK 官方文档(虚拟线程)](https://openjdk.org/jeps/444)
    -   [OpenJDK 官方文档(JDK25)](https://openjdk.org/projects/jdk/25/)
    -   [Continuations: The magic behind virtual threads in Java by Balkrishna Rawool](https://www.youtube.com/watch?v=HQsYsUac51g)
    -   [黑马程序员深入学习 Java 并发编程，JUC 并发编程全套教程\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV16J411h7Rd/?vd_source=dff8e8da3e782503dba2b80a888e026c)

## 请思考并回答以下问题

1.  为了保护用户被骚扰，bilibili 和抖音在互相关注，或对方回复之前只允许发送一条信息，我们不需要执行这么复杂的逻辑，但请在一定程度上保护用户的权益

2.  常见的服务端推送方案有 WebSocket、短轮询、长轮询，请比较它们的优缺点，并说明为什么选择 WebSocket 来实现聊天模块

3.  在 WebSocket 协议中，握手过程是如何进行的，请简要描述客户端和服务端之间的交互过程, 我们是否能够使用握手过程来进行身份验证？如果可以，应该怎么实现？

4.  在设计和实现一个 IM 系统时，我们需要保证消息的可靠性(**消息一旦显示发送成功就必定送达对端**)和一致性(**任意时刻消息保证与发送端顺序一致**)，也就是指**可达有序、不重不漏**。设计一个 IM 必须有端到端的设计思维，底层对可靠性的保证仅能保证底层的可靠，而不能保证上层的可靠性，请你尝试在代码或文档中体现你对可靠性和一致性的理解和思考。

    - 提示：聊天系统本质上是三方通信，消息端到端的可靠性 = 上行消息可靠 + 服务端业务可靠 + 下行消息可靠

5.  我们知道 WebSocket 作为一个应用层协议，传输层依赖于 TCP 协议，但是 TCP 已经实现了一套可靠数据传输机制，如超时重传、ACK、滑动窗口等等，那么，你在问题 3 中对消息的可靠性和一致性的解决方案是否还有必要？如果有必要，请你思考并回答 TCP 究竟帮我们做到了哪一步？

6.  因为网络问题、生产者重试机制或你在问题 3 中为了保证可靠性与一致性导致的取舍等等原因，同一条消息可能被生产者重复发送，造成聊天室出现重复消息的问题。为了解决这个问题，我们需要引入 **“幂等”** 这个概念，请你尝试在代码或文档中体现你对幂等性的理解和思考。

7.  对于一个 IM 群聊，消息并发/并行发送(n 个人同时聊天)是一个很常见的场景，而并发可能导致消息顺序性发生错乱，如果消息的因果顺序性发生了错乱，对于用户来说，结果可能是灾难性的。请你尝试在代码或文档中体现你对时序性的理解和思考。

8.  为了实现聊天记录这个功能，我们需要对消息进行持久化存储。消息存储有两个常见的模型，分别是读扩散和写扩散，请你在代码中选择一个模型进行实现(你完全可以挑一个简单的模型实现，但你首先得知道哪个模型比较简单 😉)，在文档中介绍这两个模型并分析他们的优缺点和实现方案。

9.  在回答完第 7 个问题之后，想必你对并发编程也有了一定的了解(如果还没学，不要紧，学了再来看)，接下来的问题你可以不用呈现在文档上，而是对你学习的检验（答案问 ai 或者去群里问学长姐）

    1.  进程、线程、协程之间的关系是什么？Java 中是否存在协程的概念？对应的是什么？

    2.  go 语言中开启一个协程的方法是 `go func`，那么 java 中怎么开启？

    3.  JEP444 引入虚拟线程的主要目标是什么？

    4.  Java 中线程模型是怎么样的？虚拟线程又采用了怎么样的调度模型？虚拟线程的载体是什么？描述一下虚拟线程在调用 I/O 操作之后具体会发生什么事情？

    5.  虚拟线程和平台线程相比，主要特点是什么？虚拟线程总是比平台线程快吗？它的优势到底是什么？

    6.  虚拟线程应该被池化吗？

    7.  虚拟线程总是守护线程吗？

    8.  什么是虚拟线程的 `Thread Pinning`？什么情况下会发生？（PS：在 JDK25 解决了）

    9.  在引入虚拟线程之前，对于一个 Java Web 应用，是一个请求对应一个线程吗？引入虚拟线程之后呢？

    10. 为什么虚拟线程不建议使用 ThreadLocal？为了解决这个问题，JDK 引入了什么？

    11. 既然提到了 ThreadLocal，那么来聊聊 ThreadLocal。ThreadLocal 是什么？我们通常在什么地方使用到 ThreadLocal？

    12. Thread, ThreadLocal, ThreadLocalMap 之间的关系是什么？

    13. ThreadLocal 的内存泄露问题是什么？为什么要用弱引用？不用如何？

    14. 真的内存泄露吗？(下面几个问题都相对比较难，直接给出回答)

        <details>
        <summary>真的内存泄漏了吗？ (点击展开/折叠)</summary>

        我们都知道在一个常规的 java web 应用中，ThreadLocal 常用于保存请求线程的用户信息，在过滤器中解析到 Token 携带的用户信息然后保存到 ThreadLocal 里，后续直接调用 get 就行

        一个常见的类长这样：

        ```java
        public class RequestHolder {

            private static final ThreadLocal<RequestInfo> threadLocal = new ThreadLocal<>();

            public static void set(RequestInfo requestInfo) {threadLocal.set(requestInfo);}

            public static RequestInfo get() {
                return threadLocal.get();
            }

            public static void remove() {
                threadLocal.remove();
            }
        }
        ```

        注意到 ThreadLocal 这个变量被 static final 修饰了。
        那么这个 ThreadLocal 变量将一直是一个强引用，他的生命周期是一整个应用程序，也就不存在被 GC 回收这一说法！！！
        所以，在 Java Web 应用中用来保存用户信息的 ThreadLocal 不会出现 “key 为 null 而 value 仍被强引用” 的内存泄漏问题
        那么，是不是不需要进行 remove 了呢？

        来看看还有什么问题

        1. 线程复用导致的 value 积累

            我们知道 Tomcat 容器使用线程池管理线程，并且线程会进行复用，如果每次使用 ThreadLocal 后不调用 remove()，ThreadLocalMap 中存储的 value 会被新值覆盖，旧值理论上会被 GC 回收。
            但是如果业务逻辑中存在“某些线程长期不更新 Value”的情况（例如线程池中的线程被偶尔使用，且 value 是大对象），这些 Value 会一直被线程的 ThreadLocalMap 持有，长期积累可能导致内存占用过高，然后 oom

        2. 类卸载

            若 ThreadLocal 所在的类被类加载器卸载，那么 即使是 static final 修饰 ThreadLocal 对象也会被回收，此时会导致 “key 为 null 而 value 仍被强引用” 的内存泄漏问题

        什么时候会发生类卸载？看看 ai 怎么说

        -    热部署（Hot Swapping/Deployment） 💡：在 Web 服务器（如 Tomcat）或 OSGi 这样的模块化框架中，当你更新一个应用的 .jar 或 .war 文件时，服务器会创建一个新的 ClassLoader 来加载新版本的类，并丢弃掉加载旧版本类的旧 ClassLoader。当旧 ClassLoader 和它加载的类的所有实例都变得不可达时，旧版本的类就会被卸载，从而实现了在不重启服务的情况下更新应用。
        -    动态代理（Dynamic Proxies）：像 Spring 和 Hibernate 这类框架，在运行时会动态生成一些代理类（例如 `...$$EnhancerBySpringCGLIB$$...`）。这些代理类由特定的 ClassLoader 加载，当它们不再被需要时，就有可能被卸载。
        -    插件化系统：一些大型应用或 IDE（如 Eclipse、IntelliJ IDEA）支持插件化架构。每个插件都由独立的 ClassLoader 加载。当你卸载或更新一个插件时，其对应的 ClassLoader 会被废弃，从而触发插件中相关类的卸载。

        </details>

    15. ThreadLocalMap 是一个特殊的哈希表，它是怎么去解决冲突的？

        <details>
            <summary>ThreadLocalMap 如何解决冲突(点击展开/折叠)</summary>
            
            ThreadLocalMap 使用线性探测解决冲突，而不是链表+红黑树。和传统的线性探测不一样的点是 remove 直接置为 null，而不是 delete 标记。
        </details>

    16. ThreadLocalMap 中 Key 的清理机制？

        <details>
            <summary>ThreadLocalMap 中 Key 的清理机制(点击展开/折叠)</summary>
            
            存在两种机制，分别是探测式清理 `expungeStaleEntry()` 和 启发式清理 `cleanSomeSlots()`

            探测式清理是以当前 Entry 往后清理，遇到值为 null 则结束清理，属于线性探测清理

            启发式清理，跳跃式清理，每次向右移动 1 位

            有如下机制：ThreadLocalMap 的清理 Key 为 null 的 Entry 不一定触发，如果触发会进行清理+reset，范围是 key 为 null 的 Entry 到下一个 null。

        </details>

    17. 书写上述问题的目的并不是故意刁难你，而是希望你能够建立你的知识体系，先做 bfs 再做 dfs。篇幅有限，还有很多问题就不继续深入了，但是如果你还想被继续追问的话，你可以按下面这个思路去做广搜和深搜：

        - ThreadLocalMap 是一个特殊的哈希表，那么原生的哈希表是怎么实现的？它线程安全吗？线程安全的实现是什么？

        - 提到虚拟线程，那么在虚拟线程之前 Java 是怎么优化并发资源问题的 -> 线程池

        - 并发安全 -> synchronized，reentrantlock，aqs....
